#!/bin/bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_BOOLEAN([pdf],[p],[If passed, the script will not open the man page, it will just open it as a PDF.])
# ARG_OPTIONAL_BOOLEAN([where],[w],[Don't actually show the man page, but print the URL of the matching page, if found.])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Print debug information too],[off])
# ARG_OPTIONAL_BOOLEAN([try-local],[t],[If there's a local man page available, don't try to fetch from network],[on])
# ARG_OPTIONAL_SINGLE([output],[o],[The output file. If passed, the script will not open the man page, it will just save it to disk in roff format. When combined with the --pdf option, it will save the PDF to the provided filename.])
# ARG_POSITIONAL_SINGLE([name-or-url],[You can pass either the name of the man page, the URL to a manned.org page, or the URL to any raw man page in roff format (hosted at manned.org or not)])
# ARG_POSITIONAL_SINGLE([section],[],[""])
# ARG_DEFAULTS_POS([])
# ARG_HELP([ManWEB - Open a man page from Manned.org\n],[],[h],[help],[Prints this help])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='pwdtoh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_name_or_url=
_arg_section=""
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_pdf="off"
_arg_where="off"
_arg_debug="off"
_arg_try_local="on"
_arg_output=


print_help()
{
	printf '%s\n' "ManWEB - Open a man page from Manned.org
"
	printf 'Usage: %s [-p|--(no-)pdf] [-w|--(no-)where] [-d|--(no-)debug] [-t|--(no-)try-local]\n' "$0"
        printf '\t%s\n' "[-o|--output <arg>] [-h|--help] <name-or-url> [<section>]\n"
	printf '\t%s\n' "<name-or-url>: You can pass either the name of the man page, the URL to a" 
        printf '\t\t%s\n' "manned.org page, or the URL to any raw man page in roff format (hosted at manned.org or not)"
	printf '\t%s\n' "-p, --pdf, --no-pdf: If passed, the script will not open the man page, it will just open it"
        printf '\t\t%s\n' "as a PDF. (off by default)"
	printf '\t%s\n' "-w, --where, --no-where: Don't actually show the man page, but print the URL of the matching"
        printf '\t\t%s\n' "page, if found. (off by default)"
	printf '\t%s\n' "-d, --debug, --no-debug: Print debug information too (off by default)"
	printf '\t%s\n' "-t, --try-local, --no-try-local: If there's a local man page available, don't try to fetch"
        printf '\t\t%s\n' "from network (on by default)"
	printf '\t%s\n' "-o, --output: The output file. If passed, the script will not open the man page, it will just"
        printf '\t\t%s\n' "save it to disk in roff format. When combined with the --pdf option, it will save the PDF to"
        printf '\t\t%s\n' "the provided filename. (no default)"
	printf '\t%s\n' "-h, --help: Prints this help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-p|--no-pdf|--pdf)
				_arg_pdf="on"
				test "${1:0:5}" = "--no-" && _arg_pdf="off"
				;;
			-p*)
				_arg_pdf="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-w|--no-where|--where)
				_arg_where="on"
				test "${1:0:5}" = "--no-" && _arg_where="off"
				;;
			-w*)
				_arg_where="on"
				_next="${_key##-w}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-w" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-d|--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			-d*)
				_arg_debug="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-t|--no-try-local|--try-local)
				_arg_try_local="on"
				test "${1:0:5}" = "--no-" && _arg_try_local="off"
				;;
			-t*)
				_arg_try_local="on"
				_next="${_key##-t}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-t" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'name-or-url'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_name_or_url _arg_section "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv

DEBUG=0
if [[ "$_arg_debug" == "on" ]]; then
    DEBUG=1
fi

# Figure out if we're dealing with a name or a URL
if [[ "$_arg_name_or_url" =~ ^https?://.* ]]; then
    # We're dealing with a URL
    URL="$_arg_name_or_url"

    echo "URL: $URL"

    if [[ "$URL" =~ ^https?://manned.org/.* ]]; then
        # We're dealing with a manned.org URL
        echo "manned.org URL"

        # If the URL contains a single path "/man/", we need to replace it with
        # "/raw/"
        if [[ "$URL" =~ .*/man/.* ]]; then
            URL=$(sed -e 's/\/man\//\/raw\//g' <<< "$URL")
        fi
    fi

    # get name and section from the last part of the URL, after the last slash
    # /NAME.SECTION
    LAST_PATH=$(sed -e 's/.*\///g' <<< "$URL")
    NAME=$(sed -e 's/\..*//g' <<< "$LAST_PATH")
    SECTION=$(sed -e 's/.*\.//g' <<< "$LAST_PATH")
else
    # We're dealing with a name
    NAME="$_arg_name_or_url"
    SECTION="$_arg_section"
    # default to section one if not provided
    if [[ -z "$SECTION" ]]; then
        SECTION=1
    fi

    # if --try-local is provided and file exists locally render it or display
    # location
    if [[ "$_arg_try_local" == "on" ]]; then
        # run man -w
        MAN_ARGUMENTS="$NAME"
        if [[ -n "$SECTION" ]]; then
            MAN_ARGUMENTS="$SECTION $MAN_ARGUMENTS"
        fi
        COMMAND="man -w $MAN_ARGUMENTS 2>/dev/null"
        if [[ "$DEBUG" == "1" ]]; then
            echo "Running: $COMMAND"
        fi
        FILE=$(eval "$COMMAND")
        # handle local file
        if [[ -f "$FILE" ]]; then
            echo "File exists locally: $FILE"
            if [[ "$_arg_where" == "on" ]]; then
                echo "$FILE"
                exit 0
            else
                if [[ "$DEBUG" == "1" ]]; then
                    echo "Rendering to terminal with: man -l $FILE"
                fi
                man -l "$FILE"
                exit 0
            fi
        fi
        # handle no local file
        echo "File does not exist locally. Attempting to download"
    fi

    # generate raw roff URL
    URL="https://manned.org/raw/$NAME.$SECTION"
fi

# if --where is provided, just print the URL and exit
if [[ "$_arg_where" == "on" ]]; then
    echo "$URL"
    exit 0
fi

# fetch from url
FILE="/tmp/$NAME.$SECTION"
echo "Downloading file: $URL"
curl -f -A 'goggle/9.0 (x11; linux x86_64; rv:60.0) gecko/20100101 chrome/103.0.5060.71' -s "$URL" > "$FILE"
# exit on 404
if [[ "$?" == "22" ]]; then
    echo "Online man page not found"
    exit 1
fi

# exit on error
if [[ "$?" != "0" ]]; then
    echo "Error downloading online man page"
    exit 1
fi

if [[ "$DEBUG" == "1" ]]; then
    echo "File saved to: $FILE"
fi

# if requested, render to terminal
# render if neithr --pdf, --output or --where are provided
if [[ "$_arg_pdf" == "off" && -z "$_arg_output" && "$_arg_where" == "off" ]]; then
    if [[ "$DEBUG" == "1" ]]; then
        echo "Rendering to terminal with: man -l $FILE"
    fi
    man -l "$FILE"
    exit 0
fi

# if requested, generate pdf
if [[ "$_arg_pdf" == "on" ]]; then
    # first, check if bin manpdf exists
    if [[ -x "$(command -v manpdf)" ]]; then
        # if requested, save to file
        if [[ -n "$_arg_output" ]]; then
            OUTPUT="$_arg_output"
            if [[ "$DEBUG" == "1" ]]; then
                echo "Saving to pdf with: manpdf --no-open-pdf --output $OUTPUT $FILE"
            fi
            manpdf --no-open-pdf --output "$OUTPUT" "$FILE"
            echo "Saved to $OUTPUT"
            exit 0
        fi
        if [[ "$DEBUG" == "1" ]]; then
            echo "Rendering to pdf with: manpdf $FILE"
        fi
        manpdf "$FILE"
        exit 0
    else
        echo "Manpdf not found. Please install it to render to pdf"
        exit 1
    fi
fi

# if requested, save to file (roff)
if [[ -n "$_arg_output" ]]; then
    OUTPUT="$_arg_output"
    if [[ "$DEBUG" == "1" ]]; then
        echo "Saving to file with: cp $FILE $OUTPUT"
    fi
    cp "$FILE" "$OUTPUT"
    echo "Saved to $OUTPUT"
    echo "You can open it by running: man -l $OUTPUT"
    exit 0
fi

# ] <-- needed because of Argbash
