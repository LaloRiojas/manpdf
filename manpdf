#!/usr/bin/env bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([output],[o],[The output file])
# ARG_OPTIONAL_SINGLE([pdf-viewer],[],[The command to open the PDF file (defaults to "xdg-open" or "open" if not provided)])
# ARG_OPTIONAL_BOOLEAN([open-pdf],[],[Open the PDF file after creating it],[on])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Print debug information too],[off])
# ARG_POSITIONAL_SINGLE([name-or-file],[You can pass either the name of the man page, a man page file (local or URL), or "-" to read file from stdin])
# ARG_POSITIONAL_SINGLE([section],[],[""])
# ARG_DEFAULTS_POS([])
# ARG_HELP([ManPDF - Open a man page as a PDF file.\n],[],[h],[help],[Prints this help])
# ARG_VERSION([echo $(basename $0) 420.69])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='odhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_name_or_file=
_arg_section=""
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output=
_arg_pdf_viewer=
_arg_open_pdf="on"
_arg_debug="off"

print_help()
{
	printf '%s\n' "ManPDF - Open a man page as a PDF file.
"
	printf 'Usage: %s [OPTIONS] <name-or-file> [<section>]\n' "$0"
	printf '\t%s\n' "<name-or-file>:"
        printf '\t\t%s\n' "You can pass either the name of the man page, a man page file"
	printf '\t\t%s\n' "(local or URL), or '-' to read file from stdin."
	printf '\t%s\n' "-o, --output:"
	printf '\t\t%s\n' "The output file."
	printf '\t\t%s\n' "(defaults to temporary file)"
	printf '\t%s\n' "--pdf-viewer:"
	printf '\t\t%s\n' "The command to open the PDF file."
	printf '\t\t%s\n' "(defaults to 'xdg-open' or 'open' if not provided)"
	printf '\t%s\n' "--open-pdf, --no-open-pdf:"
	printf '\t\t%s\n' "Open the PDF file after creating it"
	printf '\t\t%s\n' "(on by default)"
	printf '\t%s\n' "-d, --debug, --no-debug:"
	printf '\t\t%s\n' "Print debug information too."
	printf '\t\t%s\n' "(off by default)"
	printf '\t%s\n' "-h, --help:"
	printf '\t\t%s\n' "Prints this help."
	printf '\t%s\n' "-v, --version:"
	printf '\t\t%s\n' "Prints version."
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			--pdf-viewer)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_pdf_viewer="$2"
				shift
				;;
			--pdf-viewer=*)
				_arg_pdf_viewer="${_key##--pdf-viewer=}"
				;;
			--no-open-pdf|--open-pdf)
				_arg_open_pdf="on"
				test "${1:0:5}" = "--no-" && _arg_open_pdf="off"
				;;
			-d|--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			-d*)
				_arg_debug="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $(basename $0) 420.69
				exit 0
				;;
			-v*)
				echo $(basename $0) 420.69
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'name-or-file'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_name_or_file _arg_section "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# vvv  PLACE YOUR CODE HERE  vvv

# Figure out if we're dealing with a name, a file, a URL, or stdin
if [[ "$_arg_name_or_file" == "-" ]]; then
  # Handle stdin
  if [[ -t 0 ]]; then
    echo "No file piped from stdin." 1>&2
    exit 1
  else
    FILE=$(mktemp)
    cat /dev/stdin > $FILE

    # try to get name from file, if not found, default to "stdin"
    NAME="$(grep -m 1 -e '\.Nm' -e '\.TH' $FILE | awk '{print $2}')"
    if [[ -z "$NAME" ]]; then
      NAME="stdin"
    fi
  fi
elif [[ "$_arg_name_or_file" =~ ^https?:// ]]; then
  # Handle URL
  # Use curl to download file (using Chrome user agent)
  NAME=$(basename "$_arg_name_or_file")
  FILE="/tmp/$NAME"
  if [[ "$_arg_debug" == "on" ]]; then
    echo "Downloading file: $_arg_name_or_file"
  fi
  curl -A 'Goggle/9.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Chrome/103.0.5060.71' -s "$_arg_name_or_file" > "$FILE"
elif [[ -f "$_arg_name_or_file" ]]; then
  # Handle file
  NAME=$(basename "$_arg_name_or_file")
  FILE="$_arg_name_or_file"
else
  # Handle name
  # try to use 'man -w' to get file, optionally passing section if provided
  NAME="$_arg_name_or_file"
  MAN_ARGUMENTS="$NAME"
  SECTION="$_arg_section"
  if [[ -n "$SECTION" ]]; then
    MAN_ARGUMENTS="$SECTION $MAN_ARGUMENTS"
  fi
  FILE=$(man -w $MAN_ARGUMENTS)

  # If man command failed, exit
  if [[ $? -ne 0 ]]; then
    exit 1
  fi
fi

# Some distros have gzipped man pages, so we need to gunzip it before
# passing it to groff.
if [[ "$FILE" == *.gz ]]; then
  if [[ "$_arg_debug" == "on" ]]; then
    echo "Gunzipping file: $FILE"
  fi

  # gunzip the file
  UNZIPPED_FILE_NAME="/tmp/$(basename $FILE .gz)"
  gunzip -c $FILE > $UNZIPPED_FILE_NAME
  FILE=$UNZIPPED_FILE_NAME

  if [[ "$_arg_debug" == "on" ]]; then
    echo "Gunzipped file: $FILE"
  fi
fi

# get output file. If no output is provided default to /tmp/NAME.pdf
OUTPUT="/tmp/$NAME.pdf"
if [[ -n "$_arg_output" ]]; then
  OUTPUT="$_arg_output"
fi

# run the command
echo "Generating PDF for '$NAME'"

COMMAND="groff -Tpdf -mandoc -c -t -k $FILE > $OUTPUT"
if [[ "$_arg_debug" == "on" ]]; then
  echo "Running command: $COMMAND"
fi
eval $COMMAND 2>/dev/null

# if it failed, assume the groff version doesn't have the pdf device
# (i.e. "groff-base" on Debian) so try to run it with the ps device and
# convert it to pdf.
if [[ $? -ne 0 ]]; then
  # convert to ps
  PS_FILE="/tmp/$NAME.ps"
  COMMAND="groff -Tps -mandoc -c -t -k $FILE > $PS_FILE"
  if [[ "$_arg_debug" == "on" ]]; then
    echo "manpdf: groff failed, trying with ps device"
    echo "Running command: $COMMAND"
  fi
  eval $COMMAND 2>/dev/null

  # If it failed again, there's nothing we can do
  if [[ $? -ne 0 ]]; then
    echo "groff failed, exiting" 1>&2
    exit 1
  fi

  # convert to pdf
  COMMAND="ps2pdf $PS_FILE $OUTPUT"
  if [[ "$_arg_debug" == "on" ]]; then
    echo "Running command: $COMMAND"
  fi
  eval $COMMAND 2>/dev/null

  # If ps2pdf failed, just rename the file to .pdf, which
  # should be fine most of the time
  if [[ $? -ne 0 ]]; then
    if [[ "$_arg_debug" == "on" ]]; then
      echo "manpdf: ps2pdf failed, renaming file to .pdf"
    fi
    mv $PS_FILE $OUTPUT
  fi
fi

# open the file if we are told to
if [[ "$_arg_open_pdf" == "on" ]]; then
  # Æ’igure out which program to use to open the file
  if [[ -n "$_arg_pdf_viewer" ]]; then
    # if pdf viewer is explicitly passed, use that
    pdf_viewer="$_arg_pdf_viewer"
  else
    # use open or, if not available, xdg-open
    pdf_viewer="open"
    if ! command -v $pdf_viewer &> /dev/null; then
      pdf_viewer="xdg-open"
    fi
  fi

  # if debug is on, print the open program
  if [[ "$_arg_debug" == "on" ]]; then
    echo "Opening PDF with: $pdf_viewer"
  fi

  $pdf_viewer $OUTPUT
fi

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
